##############
# BASIC SETUP
##############

typeset -U PATH
autoload colors; colors;

##########
# HISTORY
##########

HISTFILE=$HOME/.zsh_history
HISTSIZE=50000
SAVEHIST=50000

setopt INC_APPEND_HISTORY     # Immediately append to history file.
setopt EXTENDED_HISTORY       # Record timestamp in history.
setopt HIST_EXPIRE_DUPS_FIRST # Expire duplicate entries first when trimming history.
setopt HIST_IGNORE_DUPS       # Dont record an entry that was just recorded again.
setopt HIST_IGNORE_ALL_DUPS   # Delete old recorded entry if new entry is a duplicate.
setopt HIST_FIND_NO_DUPS      # Do not display a line previously found.
setopt HIST_IGNORE_SPACE      # Dont record an entry starting with a space.
setopt HIST_SAVE_NO_DUPS      # Dont write duplicate entries in the history file.
setopt SHARE_HISTORY          # Share history between all sessions.
unsetopt HIST_VERIFY          # Execute commands using history (e.g.: using !$) immediately

#############
# COMPLETION
#############

# Add completions installed through Homebrew packages
# See: https://docs.brew.sh/Shell-Completion
if type brew &>/dev/null; then
  FPATH=/usr/local/share/zsh/site-functions:$FPATH
fi

# Speed up completion init, see: https://gist.github.com/ctechols/ca1035271ad134841284
autoload -Uz compinit
for dump in ~/.zcompdump(N.mh+24); do
  compinit
done
compinit -C

# unsetopt menucomplete
unsetopt flowcontrol
setopt auto_menu
setopt complete_in_word
setopt always_to_end
setopt auto_pushd

zstyle ':completion:*' matcher-list 'm:{a-z}={A-Za-z}'

# zsh-autosuggestions, zsh-syntax-highlighting and zsh-completions
source $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh
source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# zoxide
alias cd="z"
eval "$(zoxide init zsh)"

# fzf
source <(fzf --zsh)

# eza
alias ls="eza"
export FPATH="$HOME/zsh.d/eza/completions/zsh:$FPATH"

# uv & python
eval "$(uv generate-shell-completion zsh)"
export PATH="/Users/jaksa/.local/bin:$PATH"

# rustup
export PATH="$HOME/.cargo/bin:$PATH"

# golang
export PATH=$PATH:$HOME/go/bin

# bun completions
[ -s "/Users/jaksa/.bun/_bun" ] && source "/Users/jaksa/.bun/_bun"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

# pnpm
export PNPM_HOME="/Users/jaksa/Library/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
# pnpm end

# nvm
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# psql
export PATH="/opt/homebrew/opt/postgresql@17/bin:$PATH"

# git
alias monsterclean='git clean -fdx -e .jj/'
alias gst='git status'
alias gaa='git add -A'
alias gc='git commit'
alias gcm='git checkout main'
alias gd='git diff'
alias gdc='git diff --cached'
# [c]heck [o]ut
alias co='git checkout'
# [f]uzzy check[o]ut
fo() {
  git branch --no-color --sort=-committerdate --format='%(refname:short)' | fzf --header 'git checkout' | xargs git checkout
}
# [p]ull request check[o]ut
po() {
  gh pr list --author "@me" | fzf --header 'checkout PR' | awk '{print $(NF-5)}' | xargs git checkout
}
alias up='git push'
alias upf='git push --force-with-lease'
alias pu='git pull'
alias pur='git pull --rebase'
alias fe='git fetch'
alias re='git rebase'
alias lr='git l -20'
alias cdr='cd $(git rev-parse --show-toplevel)' # cd to git Root
alias hs='git rev-parse --short HEAD'
alias hm='git log --format=%B -n 1 HEAD'

alias gh-create-private='gh repo create --private --source=. --remote=origin && git push -u --all && gh browse'
alias gh-create-public='gh repo create --public --source=. --remote=origin && git push -u --all && gh browse'

# jj aliases
# Most of that stuff is taken from here: https://x.com/dimfeld/status/1926863685487559038
# Workflow:
#   jj commit
#   jjub
#   jj git push

# Get the closest ancestor bookmark
alias jjpb="jj log -r 'latest(heads(ancestors(@) & bookmarks()), 1)' --limit 1 --no-graph --ignore-working-copy -T bookmarks | tr -d '*'"

# jj update branch
jj-update-branch() {
  REV=${1:-@}
  if [ $# -gt 0 ]; then
    shift
  fi
  jj bookmark move $(jjpb) --to "$REV" "$@"
}

alias jjub=jj-update-branch
alias jn='jj new'
alias jc='jj commit'
alias js='jj status'
alias jf='jj git fetch'
alias jp='jj git push'
alias jd='jj diff'
alias jjl="jj log"
alias jjlt="jj log -r 'latest(ancestors(trunk()), 10)' --color=always -T 'builtin_log_oneline'"
alias jl="jj log"
alias jlr="jj lr"

# source <(COMPLETE=zsh jj)

export PATH="/Users/jaksa/.composer/vendor/bin":$PATH

alias claude="/Users/jaksa/.claude/local/claude"

alias par='php artisan'
alias sar='./vendor/bin/sail artisan'
alias sail='./vendor/bin/sail'
alias pint='./vendor/bin/pint'
alias phpstan='./vendor/bin/phpstan'
alias rector='./vendor/bin/rector'

export PATH="/opt/homebrew/opt/python@3.12/libexec/bin:$PATH"

#########
# PROMPT
#########

setopt prompt_subst

jj_prompt_info() {
  local dirty="%{$fg_bold[red]%} X%{$reset_color%}"
  local clean=""
  local conflicts="%{$fg_bold[yellow]%} !%{$reset_color%}"

  # Get bookmark and change info
  local bookmark=$(jj log -r @ --no-graph -T 'bookmarks' 2> /dev/null | tr -d '*' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
  local change_id=$(jj log -r @ --no-graph -T 'change_id.shortest()' 2> /dev/null) || return

  # Check working copy status
  local wc_status=""
  if jj status | grep -q "Working copy changes:"; then
    wc_status=$dirty
  elif jj log -r @ --no-graph -T 'conflict' 2> /dev/null | grep -q "true"; then
    wc_status=$conflicts
  else
    wc_status=$clean
  fi

  # Show bookmark if exists, otherwise change ID
  local ref_display="${bookmark:-$change_id}"
  echo " %{$fg_bold[green]%}${ref_display}${wc_status}%{$reset_color%}"
}

vcs_prompt_info() {
  local dirty="%{$fg_bold[red]%} X%{$reset_color%}"
  local clean=""

  # Check if we're forcing git mode
  if [[ "$VCS_PROMPT_MODE" == "git" ]]; then
    # Force git mode - show git info even if jj is available
    local dirstatus="$clean"
    if [[ ! -z $(git status --porcelain 2> /dev/null | tail -n1) ]]; then
      dirstatus=$dirty
    fi

    ref=$(git symbolic-ref HEAD 2> /dev/null) || \
    ref=$(git rev-parse --short HEAD 2> /dev/null) || return
    echo " %{$fg_bold[green]%}${ref#refs/heads/}$dirstatus%{$reset_color%}"
    return
  fi

  # Default behavior: check if we're in a jj repo
  if command -v jj &>/dev/null && jj status &>/dev/null; then
    jj_prompt_info
    return
  fi

  # Fallback to Git
  local dirstatus="$clean"
  if [[ ! -z $(git status --porcelain 2> /dev/null | tail -n1) ]]; then
    dirstatus=$dirty
  fi

  ref=$(git symbolic-ref HEAD 2> /dev/null) || \
  ref=$(git rev-parse --short HEAD 2> /dev/null) || return
  echo " %{$fg_bold[green]%}${ref#refs/heads/}$dirstatus%{$reset_color%}"
}

# local dir_info_color="$fg_bold[black]"
# magenta bold
# local dir_info_color="$fg_bold[magenta]"
# yellow-ish bold
# local dir_info_color="%B%F{172}"
# gruvbox yellow, bold
# local dir_info_color="%B%F{#fabd2f}"
# gruvbox grey
# local dir_info_color="%F{#7c6f64}"

# This just sets the color to "bold".
# Future me. Try this to see what's correct:
#   $ print -P '%fg_bold[black] black'
#   $ print -P '%B%F{black} black'
#   $ print -P '%B black'
local dir_info_color="%B"

local dir_info_color_file="${HOME}/.zsh.d/dir_info_color"
if [ -r ${dir_info_color_file} ]; then
  source ${dir_info_color_file}
fi

local dir_info="%{$dir_info_color%}%(5~|%-1~/.../%2~|%4~)%{$reset_color%}"
local promptnormal="φ %{$reset_color%}"
local promptjobs="%{$fg_bold[red]%}φ %{$reset_color%}"

PROMPT='${dir_info}$(vcs_prompt_info) %(1j.$promptjobs.$promptnormal)'

simple_prompt() {
  local prompt_color="%B"
  export PROMPT="%{$prompt_color%}$promptnormal"
}

########
# ENV
########

export COLOR_PROFILE="dark"
export LSCOLORS="Gxfxcxdxbxegedabagacad"

# Reduce delay for key combinations in order to change to vi mode faster
# See: http://www.johnhawthorn.com/2012/09/vi-escape-delays/
# Set it to 10ms
export KEYTIMEOUT=1

export EDITOR='code --wait'
export PSQL_EDITOR='vim -c"set filetype=sql"'
export GIT_EDITOR='code --wait'

# CODEX WORKAROUND

codex() {
  # Define project and global Codex paths
  local project_codex_dir="$PWD/.codex"
  local project_config="$project_codex_dir/config.toml"
  local global_auth="${CODEX_GLOBAL_AUTH:-$HOME/.codex/auth.json}"

  # If a project-level config exists, set up CODEX_HOME
  if [ -f "$project_config" ]; then
    export CODEX_HOME="$project_codex_dir"
    mkdir -p "$CODEX_HOME"

    # Symlink global auth.json into project .codex
    if [ -f "$global_auth" ]; then
      ln -sfn "$global_auth" "$CODEX_HOME/auth.json"
    else
      printf 'codex: warning: no global auth found at %s; you may need to auth once.\n' "$global_auth" >&2
    fi
  fi

  # Proxy all arguments to the real codex binary
  command codex "$@"
}
